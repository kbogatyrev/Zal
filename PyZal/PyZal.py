import os
from ctypes import *
import re
import logging
import sys


#
#  Data structures (they map C++ interfaces defined in MainLib)
#
class StWordForm(Structure):

    """
   struct StWordForm {

        long long llLexemeId;
        wchar_t szWordForm[MAX_SIZE];
        wchar_t szStem[MAX_SIZE];
        ET_PartOfSpeech ePos;
        ET_Case eCase;
        ET_Number eNumber;
        ET_Subparadigm eSubparadigm;
        ET_Gender eGender;
        ET_Person ePerson;
        ET_Animacy eAnimacy;
        ET_Reflexive eReflexive;
        ET_Aspect eAspect;
        ET_Status eStatus;
        bool bIrregular;      // came from the DB as opposed to being generated by the app
        wchar_t* szLeadComment[MAX_SIZE];
        wchar_t* szTrailingComment[MAX_SIZE];
        bool bIsEdited;
        bool bIsVariant;
        char arrStress[MAX_SIZE] = { 0 };
        wchar_t szGrammHash[MAX_SIZE];
    };
    """
    _fields_=[("llLexemeId", c_longlong),  \
              ("szWordForm", type(create_unicode_buffer(1000))),  \
              ("szStem", type(create_unicode_buffer(1000))),     \
              ("ePos", c_int), \
              ("eCase", c_int), \
              ("eNumber", c_int), \
              ("eSubparadigm", c_int), \
              ("eGender", c_int), \
              ("ePerson", c_int), \
              ("eAnimacy", c_int), \
              ("eReflexive", c_int), \
              ("eAspect", c_int), \
              ("eStatus", c_int), \
              ("bIrregular", c_bool), \
              ("szLeadComment", type(create_unicode_buffer(1000))), \
              ("szTrailingComment", type(create_unicode_buffer(1000))), \
              ("bIsEdited", c_bool), \
              ("bIsVariant", c_bool), \
              ("arrStress", type(create_string_buffer(1000))), \
              ("szGrammHash", type(create_unicode_buffer(1000)))]

#
#  Parser
#
class Parser:
    def __init__(self, lib_path, db_path):

        try:
            self.zal_lib = cdll.LoadLibrary(lib_path)
            if self.zal_lib is None:
                return False

            ret = self.zal_lib.Init(db_path)
            if not ret:
                return False

            self.parses = []

        except Exception as e:
            print(e)

    # Get a word without accents, send to Zal parser


    def parse_word_form(self, input_word):
   
        if self.zal_lib is None:
            print ('Parser library was not initialized. Exiting.')
            return False

        ret = self.zal_lib.bParseWord(input_word)
        if not ret:
            return False

        for iIdx in range (self.zal_lib.iNumOfParses()):
            parse = StWordForm()

#            p_parse = pointer(parse)

#           bool GetParsedWordForm(int iNum, StWordForm* pstParsedForm);
            self.zal_lib.GetParsedWordForm.argtypes = [c_int, POINTER(StWordForm)]
            ret = self.zal_lib.GetParsedWordForm(0, byref(parse))

            print('wordform = {}'.format(parse.szWordForm))

    #  parse_word_form

#
#  Analyzer
#
class Analyzer:

    def __init__(self, lib_path):
        self.lib_path = None
        self.data_path = None
        self.text = []
        self.collection = None
        self.book = None
        self.title = None
        self.date = None

    def handle_metadata_line(self, tag_name, text):
        if 'collection' == tag_name:
            self.collection = text
            return True
        elif 'book' == tag_name:
            self.book = text
            return True
        elif 'title' == tag_name:
            self.title = text
            return True
        elif 'date' == tag_name:
            self.date = text
            return True
        else:
            return False

        return False

    def read(self, data_path):
        try:
            with open (data_path, encoding='utf-16', mode='r') as reader:
                for line in enumerate(reader):
                    line = reader.readline(1000)
                    match = re.match(r"^\<(.+?)\s+(.+)/(.+)>", line)

                    if match != None:
                        start_tag = match.group(1)
                        text = match.group(2)
                        end_tag = match.group(3)

                        if start_tag != end_tag:
                            logging.error ('Tag mismatch: %', line)
                            continue

                        if self.handle_metadata(start_tag, text) != True:
                            logging.error('Unable to parse metadata: %', line)

                    self.text.append(line)
        except Exception as e:
            logging.error ('Exception: %', sys.exc_info()[0])

        print(self.text)
        kiki = 0

#
#  DB maintenance
#
class Database:
    def __init__(self, lib_path, db_path):
        try:
            self.zal_lib = cdll.LoadLibrary(lib_path)
            if self.zal_lib is None:
                return False

            ret = self.zal_lib.Init(db_path)
            if not ret:
                return False

        except Exception as e:
            print(e)

    def add_lexeme_hashes(self):
        self.zal_lib.AddLexemeHashes()



if __name__== "__main__":

#    db_connection = sqlite3.connect ('../Zal-Windows/ZalData/ZalData.db3')
#    db_cursor = db_connection.cursor()

#    db_edited_connection = sqlite3.connect ('../Zal-Windows/ZalData/ZalData_Edited.db3')
#    db_edited_cursor = db_edited_connection.cursor()

    lib_path = '../x64/Release/MainLibCTypes.dll'
#    db_path = '../ZalData/ZalData_Dasha_Jan_22_lexeme_hashes_added.db3'
    db_path = '../ZalData/ZalData_test.db3'
    db = Database(lib_path, db_path)
    db.add_lexeme_hashes()
#    zal_lib = cdll.LoadLibrary(lib_path)
#    zal_lib.AddLexemeHashes()

#    parser = Parser(lib_path, db_path)
#    parser.parse_word_form('собака')

#    a = Analyzer(lib_path)
#    a.read("../ZalData/Pasternak.txt")

os._exit(0)

