// MainLibManaged.h

#pragma once

#include "IDictionary.h"
#include "ILexeme.h"
#include "IWordForm.h"
#include "Gramhasher.h"
#include "IParser.h"
#include "IVerifier.h"
#include "IAspectPair.h"
#include "..\Hlib-Windows\SqliteWrapper.h"
#include "EnumsManaged.h"

using namespace System;
using namespace System::Collections::Generic;
using namespace Hlib;

namespace MainLibManaged 
{
    public delegate void DelegateProgress(int iPercentDone, bool bOperationComplete);

    ref class CLexemeManaged;
    ref class CParserManaged;
    ref class CVerifierManaged;

    public ref class CWordFormManaged
    {
        IWordForm * m_pWordForm;

    public:
        CWordFormManaged(IWordForm *);
        ~CWordFormManaged();

        CLexemeManaged^ Lexeme();
        String^ sWordForm();
        String^ sLemma();
        __int64 llLexemeId();
        EM_PartOfSpeech ePos();
        EM_Case eCase();
        EM_Number eNumber();
        EM_Subparadigm eSubparadigm();
        EM_Gender eGender();
        EM_Person ePerson();
        EM_Animacy eAnimacy();
        EM_Reflexive eReflexive();
        EM_Aspect eAspect();
        EM_Status eStatus();
        bool bIrregular();      // came from the DB as opposed to being generated by the app
        EM_ReturnCode eGetFirstStressPos(int% iPos, EM_StressType% eType);
        EM_ReturnCode eGetNextStressPos(int% iPos, EM_StressType% eType);

        String^ sGramHash();
        EM_ReturnCode eInitFromHash(String^ sHash);
    };

    public ref class CLexemeManaged
    {
    public:
        ILexeme * m_pLexeme;

        CLexemeManaged(ILexeme *);
        ~CLexemeManaged();

//        const StLexemeProperties& stGetProperties();
//        StLexemeProperties& stGetPropertiesForWriteAccess();
		__int64 llLexemeId();
        EM_Gender eGender();
        EM_Animacy eAnimacy();
        String^ sGraphicStem();
        bool bHasIrregularForms();
        bool bHasSecondaryStress();
        bool bHasFleetingVowel();
        bool bHasYoAlternation();
        bool bHasOAlternation();
        String^ sSourceForm();
        bool bHasHomonyms();
        List<int>^ arrHomonyms();
        String^ sHeadwordComment();
        bool bIsUnstressed();
        bool bIsVariant();
        String^ sMainSymbol();
        bool bIsPluralOf();
        bool bTransitive();
        EM_Reflexive eIsReflexive();
        String^ sMainSymbolPluralOf();
        String^ sAltMainSymbol();
        EM_Aspect eAspect();
        String^ sInflectionType();
        EM_PartOfSpeech ePartOfSpeech();
        String^ sComment();
        String^ sAltMainSymbolComment();
        String^ sAltInflectionComment();
        String^ sVerbStemAlternation();
        bool bPartPastPassZhd();
        int iSection();
        bool bNoComparative();
        bool bAssumedForms();
        bool bYoAlternation();
        bool bOAlternation();
        bool bSecondGenitive();
        bool bSecondLocative();
        bool bSecondLocativeOptional();
        String^ sLoc2Preposition();
		bool bHasAspectPair();
		bool bHasAltAspectPair();
		int iAspectPairType();
		int iAltAspectPairType();
		String^ sAltAspectPairComment();
        EM_ReturnCode eGetAspectPair(String^% sAspectPair, int% iStressPos);
        EM_ReturnCode eGetAltAspectPair(String^% sAltAspectPair, int% iAltStressPos);
        String^ sQuestionableForms();
        bool bHasIrregularVariants();
        bool bHasDeficiencies();
        String^ sRestrictedForms();
        String^ sContexts();
        String^ sTrailingComment();
        int iInflectionId();
        bool bPrimaryInflectionGroup();
        int iType();
        EM_AccentType eAccentType1();
        EM_AccentType eAccentType2();
        bool bShortFormsRestricted();
        bool bPastParticipleRestricted();
        bool bNoLongForms();
        bool bShortFormsIncomplete();
        bool bNoPastParticiple();
        bool bFleetingVowel();
        int iStemAugment();
        String^ s1SgStem();
        String^ s3SgStem();
        String^ sInfinitive();
        String^ sInfStem();
        bool bFindCommonDeviation(int iNum, bool% bIsOptional);
        bool bFindStandardAlternation(String^ sKey, String^% sValue);
        EM_ReturnCode eGetStemStressPositions(String^ sLemma, List<int>% listPositions);
        EM_ReturnCode eGetAlternatingPreverb(String^ sVerbForm, String^% sPreverb, bool% bVoicing);
        String^ sHash();
        EM_ReturnCode eWordFormFromHash(String^ sHash, int iAt, CWordFormManaged^% Wf);
        bool bHasIrregularForm(String^ sGramHash);
        bool bNoRegularForms(String^ sGramHash);
        EM_ReturnCode eGetFirstWordForm(CWordFormManaged^% wf);
        EM_ReturnCode eGetNextWordForm(CWordFormManaged^% wf);
        EM_ReturnCode eGetFirstIrregularForm(String^ sHash, CWordFormManaged^%, bool% bIsOptional);
        EM_ReturnCode eGetNextIrregularForm(CWordFormManaged^%, bool% bIsOptional);
        int iFormCount(String^ sHash);
        bool bHasCommonDeviation(int iCd);
        bool bDeviationOptional(int iCd);
        bool bIsFormMissing(String^ sGramHash);
        bool bIsMultistressedCompound();
        EM_ReturnCode eGetFirstStemStressPos(int% iPos);
        EM_ReturnCode eGetNextStemStressPos(int% iPos);
//        EM_ReturnCode eSetDb(String^ sDbPath);
        EM_ReturnCode eGenerateParadigm();
//        EM_ReturnCode eBuildAspectPair();
        EM_ReturnCode eSaveTestData();

    protected:
//        EM_ReturnCode eGetAspectPair(String^%, int%, bool bIsVariant);

    };  //  public ref class CLexemeManaged

    public ref class CDictionaryManaged
    {
        Hlib::IDictionary * m_pDictionary;  // we are using some non-itf methods

    public:
        CDictionaryManaged();
        ~CDictionaryManaged();

        EM_ReturnCode eSetDbPath(String^ sDbPath);
        String^ sGetDbPath();
        EM_ReturnCode eGetLexemeById(int Id);
        EM_ReturnCode eGetLexemesByHash(String^);
        EM_ReturnCode eGetLexemesByGraphicStem(String^);
        EM_ReturnCode eGetLexemesByInitialForm(String^);
        EM_ReturnCode eGenerateAllForms();
        EM_ReturnCode eGenerateFormsForSelectedLexemes();
        MainLibManaged::EM_ReturnCode eCountLexemes(Int64% iLexemes);

        EM_ReturnCode eGetFirstLexeme(CLexemeManaged^% pLexeme);
        EM_ReturnCode eGetNextLexeme(CLexemeManaged^% pLexeme);

//        EM_ReturnCode eAnalyze(String^ sText);

//        EM_ReturnCode eGetFirstWordForm(CWordFormManaged^% pWordFrom);
//        EM_ReturnCode eGetNextWordForm(CWordFormManaged^% pWordForm);

        void Clear();
        EM_ReturnCode Clear(CLexemeManaged^ pLexeme);

        EM_ReturnCode eGetParser(CParserManaged^%); 
        EM_ReturnCode eGetVerifier(CVerifierManaged^%);
        EM_ReturnCode eExportTestData(String^ sPath, DelegateProgress^);
        EM_ReturnCode eImportTestData(String^ sPath, DelegateProgress^);
    };

    public ref class CGramHasherManaged
    {
        Hlib::CGramHasher * m_pHasher;

    public:
        CGramHasherManaged();
        ~CGramHasherManaged();

        void SetPartOfSpeech(EM_PartOfSpeech);
        void SetSubparadigm(EM_Subparadigm);
        void SetCase(EM_Case);
        void SetNumber(EM_Number);
        void SetGender(EM_Gender);
        void SetPerson(EM_Person);
        void SetAnimacy(EM_Animacy);
        void SetReflexivity(EM_Reflexive);
        void SetAspect(EM_Aspect);
        String^ sHash();
    };

    public ref class CParserManaged
    {
        Hlib::IParser * m_pParser;

    public:
        CParserManaged(IParser *);
        ~CParserManaged();

        EM_ReturnCode eAnalyze(String^ sText);
        EM_ReturnCode eGetFirstWordForm(CWordFormManaged^% pWordFrom);
        EM_ReturnCode eGetNextWordForm(CWordFormManaged^% pWordFrom);
    };

    public ref class CVerifierManaged
    {
        Hlib::IVerifier * m_pVerifier;

    public:
        CVerifierManaged(IVerifier *);
        ~CVerifierManaged();

        EM_ReturnCode eVerify(String^ sLexemeHash);
        EM_TestResult eResult();

        int iCount();

        EM_ReturnCode eLoadStoredLexemes();
        EM_ReturnCode eDeleteStoredLexeme(String^);

        EM_ReturnCode eGetFirstLexemeData(String^% sLexemeHash, String^% sHeadword);
        EM_ReturnCode eGetNextLexemeData(String^% sLexemeHash, String^% sHeadword);
    };

}       //  namespace MainLibManaged
